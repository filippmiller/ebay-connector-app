[33mcommit 5ff39c2de52099db26768f35f5ac30a27dd25a97[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmain[m[33m, [m[1;31morigin/main[m[33m)[m
Author: YOUR NAME <filippmiller@gmail.com>
Date:   Sat Nov 22 11:05:59 2025 +0300

    grid fix

[1mdiff --git a/frontend/src/components/DataGridPage.tsx b/frontend/src/components/DataGridPage.tsx[m
[1mindex d968135..a3dd479 100644[m
[1m--- a/frontend/src/components/DataGridPage.tsx[m
[1m+++ b/frontend/src/components/DataGridPage.tsx[m
[36m@@ -100,10 +100,47 @@[m [mexport const DataGridPage: React.FC<DataGridPageProps> = ({ gridKey, title, extr[m
 [m
   const orderedVisibleColumns = useMemo(() => {[m
     const cfg = gridPrefs.columns;[m
[31m-    if (!cfg) return [] as string[];[m
 [m
[31m-    const baseOrder = (cfg.order && cfg.order.length ? cfg.order : gridPrefs.availableColumns.map((c) => c.name));[m
[31m-    return baseOrder.filter((name) => cfg.visible.includes(name) && !!availableColumnsMap[name]);[m
[32m+[m[32m    // If we have no explicit columns config yet but do have metadata, fall back[m
[32m+[m[32m    // to "all available". This guards against transient or legacy states where[m
[32m+[m[32m    // the preferences payload is missing/empty but the backend is correctly[m
[32m+[m[32m    // advertising column metadata.[m
[32m+[m[32m    if (!cfg) {[m
[32m+[m[32m      if (gridPrefs.availableColumns.length > 0) {[m
[32m+[m[32m        return gridPrefs.availableColumns[m
[32m+[m[32m          .map((c) => c.name)[m
[32m+[m[32m          .filter((name) => !!availableColumnsMap[name]);[m
[32m+[m[32m      }[m
[32m+[m[32m      return [] as string[];[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Prefer the persisted order if present; otherwise fall back to visible[m
[32m+[m[32m    // list, then finally to all available metadata.[m
[32m+[m[32m    let baseOrder: string[];[m
[32m+[m[32m    if (cfg.order && cfg.order.length) {[m
[32m+[m[32m      baseOrder = cfg.order;[m
[32m+[m[32m    } else if (cfg.visible && cfg.visible.length) {[m
[32m+[m[32m      baseOrder = cfg.visible;[m
[32m+[m[32m    } else {[m
[32m+[m[32m      baseOrder = gridPrefs.availableColumns.map((c) => c.name);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    let result = baseOrder.filter((name) => {[m
[32m+[m[32m      // If visible is empty (legacy/invalid state), treat all known columns as[m
[32m+[m[32m      // visible; otherwise enforce the visible set.[m
[32m+[m[32m      const isVisible = !cfg.visible || cfg.visible.length === 0 || cfg.visible.includes(name);[m
[32m+[m[32m      return isVisible && !!availableColumnsMap[name];[m
[32m+[m[32m    });[m
[32m+[m
[32m+[m[32m    // Extreme fallback: if, after filtering, we still have no columns but[m
[32m+[m[32m    // metadata exists, just show all metadata-defined columns.[m
[32m+[m[32m    if (result.length === 0 && gridPrefs.availableColumns.length > 0) {[m
[32m+[m[32m      result = gridPrefs.availableColumns[m
[32m+[m[32m        .map((c) => c.name)[m
[32m+[m[32m        .filter((name) => !!availableColumnsMap[name]);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return result;[m
   }, [gridPrefs.columns, gridPrefs.availableColumns, availableColumnsMap]);[m
 [m
   // Recompute renderable columns whenever preferences or metadata change[m
