# Gmail Integrations & AI Email Training

This document tracks the implementation of a generic Integrations module with Gmail as the first connector, plus the email/AI training data layer.

This iteration covers:

- **Phase 0 – Audit** of existing code (backend, frontend, workers).
- **Phase 1 – DB schema** (Alembic migrations + SQLAlchemy models + credentials encryption wiring).
- **Phase 2 – Backend: Gmail OAuth2 flow & basic Integrations API**.

Subsequent iterations will add Admin UI, workers, and AI training views.

---

## Phase 2 – Backend: Gmail OAuth2 flow & basic API

### Gmail ENV configuration

Gmail-specific settings are added to the main backend config (`backend/app/config.py`) and exposed via the global `settings` object:

- `GMAIL_CLIENT_ID: Optional[str]`
- `GMAIL_CLIENT_SECRET: Optional[str]`
- `GMAIL_OAUTH_REDIRECT_BASE_URL: Optional[str]`
  - Public base URL for backend API, typically including the `/api` prefix.
  - Example: `https://api.yourdomain.com/api`.
  - The actual callback URL becomes:  
    `{GMAIL_OAUTH_REDIRECT_BASE_URL}/integrations/gmail/callback`.
- `GMAIL_OAUTH_SCOPES: str`
  - Space-separated scopes; default:  
    `"https://www.googleapis.com/auth/gmail.readonly"`.

These variables are documented and exemplified in `backend/.env.example`:

```bash path=null start=null
# Gmail OAuth (Integrations module)
# Public base URL for backend API, typically including the /api prefix,
# e.g. https://api.yourdomain.com/api
GMAIL_OAUTH_REDIRECT_BASE_URL=https://api.yourdomain.com/api
GMAIL_CLIENT_ID=your-gmail-oauth-client-id
GMAIL_CLIENT_SECRET=your-gmail-oauth-client-secret
# Optional: space-separated list of scopes; default is read-only Gmail access
GMAIL_OAUTH_SCOPES=https://www.googleapis.com/auth/gmail.readonly

At runtime, router code reads them only via from app.config import settings, never directly from os.environ.



Gmail provider seeding

The Gmail provider row is created lazily the first time a successful OAuth callback is processed.

•  Helper: _ensure_gmail_provider(db: Session) -> IntegrationProvider in  
  backend/app/routers/integrations.py.

Behavior:

•  Queries IntegrationProvider where code == "gmail".
•  If found, returns that row.
•  If not found:
◦  Builds scopes_list from settings.GMAIL_OAUTH_SCOPES (space-split).
◦  Creates:
python
•  Adds to the session, flushes to get id, and logs a short info line.

There is no separate startup seeding step; the provider row is guaranteed to exist after the first successful Gmail integration.



OAuth endpoints

All Gmail and Integrations backend endpoints are implemented in a new router:

•  File: backend/app/routers/integrations.py
•  Registered in backend/app/main.py:
python
•  Router prefix: /integrations  
  → externally (with the Cloudflare /api proxy) these are /api/integrations/....

POST /api/integrations/gmail/auth-url

Path in code: @router.post("/gmail/auth-url")

Purpose  
Return a Google OAuth URL that the frontend can redirect the browser to, in order to connect a Gmail account for the currently authenticated user.

Auth

•  current_user: User = Depends(get_current_active_user) – normal authenticated user.

Logic

1. Validate configuration
◦  If settings.GMAIL_CLIENT_ID is missing:
▪  Raise HTTP 500 with detail:  
       "Gmail OAuth is not configured (missing GMAIL_CLIENT_ID)".

2. Compute redirect URI
◦  Helper _get_gmail_redirect_uri():
python
3. Build state JSON
json
•  Serialized with json.dumps into a string passed as the state parameter.
4. Compute scopes
◦  scopes_raw = settings.GMAIL_OAUTH_SCOPES or "https://www.googleapis.com/auth/gmail.readonly"
◦  scopes = scopes_raw.split() (whitespace-separated).
◦  scope_param = " ".join(scopes) for the query string.
5. Construct Google OAuth URL
◦  Base URL: https://accounts.google.com/o/oauth2/v2/auth
◦  Query params:
python
•  Final URL via urllib.parse.urlencode.
6. Logging
◦  Logs a short INFO line containing:
▪  The user id.
▪  The computed redirect_uri.

Response
json
No secrets, tokens, or refresh tokens are logged or returned.



GET /api/integrations/gmail/callback

Path in code: @router.get("/gmail/callback")

Purpose  
Handle Google’s OAuth redirect, exchange the code for tokens, determine the Gmail address, and upsert:

•  IntegrationProvider (Gmail provider),
•  IntegrationAccount,
•  IntegrationCredentials.

Auth

•  No JWT-based auth.
•  The owner is determined solely from state generated by /gmail/auth-url.

Query parameters

•  code: Optional[str] – authorization code from Google.
•  state: Optional[str] – JSON string containing owner_user_id and a nonce.

Behavior

1. Validate presence of code and state
◦  If code is missing:
▪  Log a warning.
▪  Redirect to:

       /admin/integrations?gmail=error&reason=missing_code

•  If state is missing:
◦  Log a warning.
◦  Redirect with:

       reason=missing_state.

•  Attempt json.loads(state):
◦  On failure, log an exception and redirect with reason=invalid_state.
2. Extract owner_user_id
◦  From parsed state_data:
python
•  If missing:
◦  Log error and redirect with reason=missing_owner.
3. Prepare token exchange
◦  Token endpoint: https://oauth2.googleapis.com/token.
◦  Ensure settings.GMAIL_CLIENT_ID and settings.GMAIL_CLIENT_SECRET are present; otherwise redirect with reason=server_config.
◦  Compute redirect_uri = _get_gmail_redirect_uri() (same as in /auth-url).
◦  POST form data:
python
•  Execute via httpx.AsyncClient (30-second timeout).
•  If HTTP error → redirect reason=token_http.
•  If resp.status_code != 200 → log and redirect reason=token_failed.
•  Parse JSON:
python
•  If access_token is missing → redirect reason=missing_access_token.
4. Fetch Gmail profile to obtain the email address
◦  Call:
▪  GET https://gmail.googleapis.com/gmail/v1/users/me/profile
▪  Headers: Authorization: Bearer <access_token>.
◦  On 200:
python
•  On non-200 or missing emailAddress, log and redirect with reason=profile_failed.
5. Persist provider, account, and credentials

   Inside a try/except (rollback on error) using db: Session = Depends(get_db):

•  Call _ensure_gmail_provider(db) to get/create Gmail provider row.
•  Optionally load owner SAUser (SQLAlchemy) via db.query(SAUser).filter(SAUser.id == owner_user_id) (for logging/serialization only).
•  Upsert IntegrationAccount:
python
•  If None:
python
•  If exists:
◦  Ensure account.status = "active".
•  Upsert IntegrationCredentials:
python
•  Set encrypted properties:
python
•  Compute expiry if expires_in present:
python
•  Capture scopes:
python
•  db.commit() on success; db.rollback() with logged exception on failure, then redirect reason=persist_failed.
6. Redirect back to frontend
◦  On success:
▪  HTTP 302 to:  
       FRONTEND_URL/admin/integrations?gmail=connected

•  On any failure point:
◦  Redirect to:  
       FRONTEND_URL/admin/integrations?gmail=error&reason=<short_reason>

•  No raw tokens or refresh tokens are ever sent to the frontend.



Integrations admin API

The same router (backend/app/routers/integrations.py) also exposes backend-only admin endpoints for listing and controlling integration accounts.

•  Router prefix: /integrations → external paths /api/integrations/....
•  Auth guard: admin_required (admin-only).

GET /api/integrations/accounts

Code path: @router.get("/accounts")

Auth

•  current_user: User = Depends(admin_required) – only admins.

Query parameters

•  provider: Optional[str] – filter by provider code, e.g. gmail.
•  owner_user_id: Optional[str] – filter by owning user id.

Logic

•  Builds a joined query:
python
•  Applies filters for provider and owner_user_id if provided.
•  Orders by IntegrationProvider.code, then IntegrationAccount.display_name.
•  Serializes rows via _serialize_integration_account(acc, prov, user):
json
Response
json
Tokens and credentials are never included.



POST /api/integrations/accounts/{id}/disable

Code path: @router.post("/accounts/{account_id}/disable")

Auth

•  Admin-only via admin_required.

Logic

•  Look up IntegrationAccount by id:
◦  If missing → 404 with detail="integration_account_not_found".
•  Set status = "disabled".
•  Commit and refresh.
•  Load related IntegrationProvider and owner SAUser.
•  Log:
◦  "Integration account {id} disabled by admin {current_user.id}".

Response

•  Serialized account, same shape as entries in GET /accounts.



POST /api/integrations/accounts/{id}/enable

Code path: @router.post("/accounts/{account_id}/enable")

Auth

•  Admin-only via admin_required.

Logic

•  Same as /disable but sets status = "active" and logs an "enabled" event.

Response

•  Serialized account (updated).



POST /api/integrations/accounts/{id}/resync

Code path: @router.post("/accounts/{account_id}/resync")

Purpose

Mark an account for manual resync. The future Gmail worker will treat this as a hint.

Auth

•  Admin-only via admin_required.

Logic

•  Look up IntegrationAccount by id; 404 if missing.
•  Clone/initialize meta:
python
•  Commit & refresh.
•  Load provider and owner for serialization.
•  Log:
◦  "Manual resync requested for integration account {id} by admin {current_user.id}".

Response

•  Updated serialized account, including meta.manual_resync_requested_at.



Phase 0 – Audit (summary, unchanged)

(Kept here for completeness; no changes in this iteration.)

•  No pre-existing generic integrations module or Gmail/email connectors.
•  Existing OAuth flows & patterns live in backend/app/routers/ebay.py and related docs.
•  Encryption helper for tokens: backend/app/utils/crypto.py (AES-GCM, HKDF from settings.secret_key), now reused by IntegrationCredentials.
•  Admin frontend currently has no Integrations page; only eBay-specific connection UI.
•  Worker patterns under backend/app/workers (token refresh, health checks, eBay data workers, sniper, monitoring, auto-offer/buy) will be reused later for Gmail sync.



Phase 1 – DB schema (summary, unchanged)

(Schema & ORM are already implemented; no code changes in this phase.)

•  Alembic migration: backend/alembic/versions/gmail_integrations_20251125.py.
•  SQLAlchemy models in backend/app/models_sqlalchemy/models.py:
◦  IntegrationProvider → integrations_providers
◦  IntegrationAccount → integrations_accounts
◦  IntegrationCredentials → integrations_credentials
◦  EmailMessage → emails_messages
◦  AiEmailTrainingPair → ai_training_pairs
•  Credentials encryption is wired via IntegrationCredentials.access_token / refresh_token properties, which call app.utils.crypto.encrypt/decrypt.

(See earlier sections of this doc for full schema details.)



Testing checklist for Phase 2

1. Configure Gmail ENV (dev/local)
◦  In your backend .env:
bash
•  Ensure these are visible inside the app (settings.GMAIL_*).
2. Start backend
bash
3. Test POST /api/integrations/gmail/auth-url
◦  Obtain JWT via /auth/login.
◦  Call:
▪  POST /integrations/gmail/auth-url  
       with Authorization: Bearer <token>.

•  Confirm response shape:
json
•  Check that:
◦  client_id matches GMAIL_CLIENT_ID.
◦  redirect_uri equals {GMAIL_OAUTH_REDIRECT_BASE_URL}/integrations/gmail/callback.
◦  scope includes https://www.googleapis.com/auth/gmail.readonly (or your configured scopes).
4. End-to-end OAuth (with real Google Cloud credentials)
◦  In a browser, open the auth_url from step 3.
◦  Log in to Google and approve access.
◦  Expect final redirect to:
▪  FRONTEND_URL/admin/integrations?gmail=connected on success.
▪  FRONTEND_URL/admin/integrations?gmail=error&reason=... on failure.
◦  After a successful callback, in Postgres check:
▪  integrations_providers contains code = 'gmail'.
▪  integrations_accounts has a row with:
▪  provider_id → Gmail provider id,
▪  owner_user_id → your user id,
▪  external_account_id → your Gmail address.
▪  integrations_credentials has a row with:
▪  integration_account_id pointing to that account,
▪  encrypted access_token and (optionally) refresh_token (values stored as ENC:v1:...).
5. Verify encryption
◦  Directly inspect integrations_credentials.access_token / refresh_token in the DB:
▪  Values must be opaque (ENC:v1:...), not raw bearer tokens.
6. Test GET /api/integrations/accounts (admin)
◦  Authenticate as an admin user.
◦  Call:
▪  GET /api/integrations/accounts
▪  Optionally: GET /api/integrations/accounts?provider=gmail
◦  Verify the Gmail account appears with correct:
▪  provider_code = "gmail",
▪  external_account_id = "<gmail address>",
▪  display_name = "Gmail – <gmail address>".
7. Test /disable, /enable, /resync
◦  Pick an id from GET /accounts.
◦  Disable:
▪  POST /api/integrations/accounts/{id}/disable
▪  Confirm response status is "disabled".
◦  Enable:
▪  POST /api/integrations/accounts/{id}/enable
▪  Confirm response status is "active".
◦  Request resync:
▪  POST /api/integrations/accounts/{id}/resync
▪  Confirm meta.manual_resync_requested_at is set to a recent ISO timestamp.

These backend capabilities complete Phase 2:

•  Gmail OAuth is wired end-to-end.
•  Gmail integration metadata and tokens are stored in the generic Integrations schema, with encryption.
•  An admin-only Integrations API exists for listing, enabling/disabling, and marking accounts for resync.

They are now ready to be consumed by the next phases: Admin Integrations UI, Gmail sync worker, and AI email training dataset tooling.