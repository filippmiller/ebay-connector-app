What I changed

•  backend/app/routers/listing.py
◦  Extended ListingCommitResponse to include parts_detail_ids: List[int].
◦  On commit, for each drafted item now creates a minimal PartsDetail row in Supabase (no schema changes) and collects its ID into parts_detail_ids.
◦  Left all existing Inventory + legacy TblPartsInventory logic unchanged.
•  frontend/src/pages/ListingPage.tsx
◦  After a successful /api/listing/commit, when debug mode is enabled and parts_detail_ids are returned, automatically calls runDebugForIds with those IDs to run the listing worker and open the debug terminal.
◦  Existing commit behaviour (creating inventory, cleaning draft grid) remains unchanged.

Backend modules (listing.py, ebay_listing_service.py) compile, and npm run build in frontend/ passes.

========================  
FINAL CODE DUMP (NO LINE NUMBERS)  
========================


from typing import List, Optional, Dict, Any

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field, validator
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import func
from sqlalchemy.sql import text as sa_text
from sqlalchemy.sql.sqltypes import (
    String,
    Text,
    CHAR,
    VARCHAR,
    Unicode,
    UnicodeText,
    Integer,
    BigInteger,
    Numeric,
    Float,
    Boolean as SA_Boolean,
    DateTime as SA_DateTime,
    Date as SA_Date,
)

from app.models_sqlalchemy import get_db
from app.models_sqlalchemy.models import (
    Inventory,
    InventoryStatus,
    PartsDetail,
    PartsDetailStatus,
    SqItem,
    SKU,
    TblPartsInventory,
)
from app.services.auth import get_current_user
from app.models.user import User
from app.utils.logger import logger

router = APIRouter(prefix="/api/listing", tags=["listing"])


ALLOWED_LISTING_STATUS_MAP: Dict[str, InventoryStatus] = {
    # UI label -> InventoryStatus mapping
    "awaiting_moderation": InventoryStatus.PENDING_LISTING,
    "checked": InventoryStatus.AVAILABLE,
}


class DraftListingItemPayload(BaseModel):
    sku_code: str = Field(..., description="SqItem.sku from the SQ catalog (sq_items) table")
    price: Optional[float] = Field(None)
    quantity: int = Field(1, ge=1)
    condition: Optional[str] = None
    title: Optional[str] = None
    storage: Optional[str] = None
    status: Optional[str] = Field(None, description="UI status code (awaiting_moderation|checked)")
    warehouse_id: Optional[int] = None

    @validator("status")
    def validate_status(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        v_norm = v.strip().lower()
        if v_norm not in ALLOWED_LISTING_STATUS_MAP:
            raise ValueError("Invalid status; allowed: awaiting_moderation, checked")
        return v_norm

    @validator("sku_code")
    def validate_sku_code(cls, v: str) -> str:
        v_norm = (v or "").strip()
        if not v_norm:
            raise ValueError("sku_code is required")
        return v_norm


class ListingCommitRequest(BaseModel):
    model_id: Optional[int] = Field(None, description="Optional model id to enforce consistency")
    storage: Optional[str] = Field(None, description="Global storage fallback (e.g. B16:1)")
    default_status: Optional[str] = Field("awaiting_moderation")
    items: List[DraftListingItemPayload]

    @validator("items")
    def validate_items_non_empty(cls, v: List[DraftListingItemPayload]) -> List[DraftListingItemPayload]:
        if not v:
            raise ValueError("items must be non-empty")
        return v

    @validator("default_status", pre=True, always=True)
    def validate_default_status(cls, v: Optional[str]) -> str:
        if not v:
            return "awaiting_moderation"
        v_norm = v.strip().lower()
        if v_norm not in ALLOWED_LISTING_STATUS_MAP:
            raise ValueError("Invalid default_status; allowed: awaiting_moderation, checked")
        return v_norm


class ListingCommitItemResponse(BaseModel):
    inventory_id: int
    sku_code: str
    storage: Optional[str]
    status: str


class ListingCommitResponse(BaseModel):
    created_count: int
    items: List[ListingCommitItemResponse]
    parts_detail_ids: List[int] = Field(
        default_factory=list,
        description=(
            "IDs of parts_detail rows created for this commit. "
            "Used by the eBay listing debug worker to target fresh candidates."
        ),
    )


from datetime import datetime


def _get_or_create_simple_sku(db: Session, sq: SqItem) -> int:
    """Return ID from simplified SKU table for a given SqItem.

    The Supabase `inventory` table uses a foreign key to the modern `sku`
    table (SKU model). Historically we tried to leave `sku_id` NULL when
    committing listings directly from the legacy SQ catalog, but the real
    production schema has a NOT NULL constraint on `inventory.sku_id`.

    To keep referential integrity without changing the DB schema, we lazily
    create a minimal `SKU` row for any SqItem that does not yet have a
    corresponding simplified SKU entry, keyed by the numeric SKU value.
    """
    from decimal import Decimal

    if sq.sku is None:
        raise HTTPException(status_code=400, detail={"error": "sq_item_missing_sku", "id": sq.id})

    try:
        sku_code_str = str(int(sq.sku))
    except (TypeError, ValueError):
        raise HTTPException(
            status_code=400,
            detail={"error": "sq_item_invalid_sku", "id": sq.id, "sku": str(sq.sku)},
        )

    existing = db.query(SKU).filter(SKU.sku_code == sku_code_str).first()
    if existing:
        return existing.id

    # Derive a minimal but useful simplified SKU from the SQ catalog row.
    price_val: float = 0.0
    if sq.price is not None:
        if isinstance(sq.price, Decimal):
            price_val = float(sq.price)
        else:
            try:
                price_val = float(sq.price)
            except Exception:
                price_val = 0.0

    category_str = None
    if sq.category is not None:
        try:
            category_str = str(int(sq.category))
        except Exception:
            category_str = str(sq.category)

    simple_sku = SKU(
        sku_code=sku_code_str,
        model=None,
        category=category_str,
        condition=None,
        part_number=sq.part_number,
        price=price_val,
        title=sq.part,
        description=sq.description,
        brand=getattr(sq, "brand", None),
        image_url=sq.pic_url1,
    )

    db.add(simple_sku)
    db.flush()  # assign ID
    return simple_sku.id


def _insert_legacy_inventory_row(
    db: Session,
    sq: SqItem,
    storage_value: str,
    status_key: str,
    username: str,
    next_id: int,
    item_payload: DraftListingItemPayload,
    status_id_map: Dict[str, int],
) -> int:
    """Insert a row into legacy tbl_parts_inventory with explicit ID.

    ID is computed outside as MAX(ID)+1, then incremented per-row within the
    same commit batch so that new rows appear at the end of tbl_parts_inventory
    exactly as in the legacy flow.
    """

    table = TblPartsInventory.__table__

    insert_data: Dict[str, Any] = {"ID": next_id}

    # Case-insensitive column lookup
    cols_by_lower = {c.name.lower(): c for c in table.columns}

    # SKU
    sku_val = None
    if sq.sku is not None:
        try:
            sku_val = int(sq.sku)
        except Exception:
            try:
                sku_val = int(str(sq.sku))
            except Exception:
                sku_val = None
    if sku_val is not None:
        for key in ["sku", "skucode", "overstocksku"]:
            col = cols_by_lower.get(key)
            if col is not None:
                insert_data[col.name] = sku_val
                break

    # Quantity
    qty = item_payload.quantity or 1
    for key in ["quantity", "qty", "overstockqty"]:
        col = cols_by_lower.get(key)
        if col is not None:
            insert_data[col.name] = qty
            break

    # Storage ID
    for key in [
        "storageid",
        "storage_id",
        "storage",
        "alternativestorage",
        "alternative_storage",
        "storagealias",
        "storage_alias",
    ]:
        col = cols_by_lower.get(key)
        if col is not None:
            insert_data[col.name] = storage_value
            break

    # Title / overview title
    title_val = (item_payload.title or sq.part or sq.description or "").strip()
    if title_val:
        for key in ["overviewtitle", "title", "part", "itemtitle"]:
            col = cols_by_lower.get(key)
            if col is not None:
                insert_data[col.name] = title_val
                break

    # Description
    desc_val = (sq.description or "").strip()
    if desc_val:
        for key in ["overviewdescription", "description", "overdescription", "overdescription1"]:
            col = cols_by_lower.get(key)
            if col is not None:
                insert_data[col.name] = desc_val
                break

    # Category
    if sq.category is not None:
        try:
            cat_val: Any = int(sq.category)
        except Exception:
            cat_val = sq.category
        for key in ["categoryid", "category", "overstockcategoryid"]:
            col = cols_by_lower.get(key)
            if col is not None:
                insert_data[col.name] = cat_val
                break

    # Price
    price_val = None
    if item_payload.price is not None:
        price_val = float(item_payload.price)
    elif sq.price is not None:
        try:
            price_val = float(sq.price)
        except Exception:
            price_val = None
    if price_val is not None:
        for key in ["price", "overstockprice", "buyprice"]:
            col = cols_by_lower.get(key)
            if col is not None:
                insert_data[col.name] = price_val
                break

    # Author
    for key in ["author", "user", "overstockuser"]:
        col = cols_by_lower.get(key)
        if col is not None:
            insert_data[col.name] = username
            break

    # Legacy numeric status (StatusSKU) from tbl_parts_inventorystatus
    # Map our logical UI status key ("awaiting_moderation" / "checked")
    # to the InventoryStatus_ID value, when the lookup table is available.
    if status_id_map:
        # Normalise key: "awaiting_moderation" -> "awaiting moderation"
        base_label = status_key.replace("_", " ").strip().lower()
        status_id = status_id_map.get(base_label)
        if status_id is None:
            # Fallback: try partial matches to tolerate minor spelling/case
            # differences between UI labels and legacy dictionary entries.
            for label, sid in status_id_map.items():
                if base_label in label or label in base_label:
                    status_id = sid
                    break
        if status_id is not None:
            status_col = cols_by_lower.get("statussku")
            if status_col is not None:
                insert_data[status_col.name] = status_id

    # Rec created
    now = datetime.utcnow()
    for key in ["reccreated", "record_created", "created", "overstockcreated"]:
        col = cols_by_lower.get(key)
        if col is not None:
            insert_data[col.name] = now
            break

    # Fill NOT NULL columns without defaults with safe placeholders
    string_types = (String, Text, CHAR, VARCHAR, Unicode, UnicodeText)

    for col in table.columns:
        if col.name in insert_data:
            continue
        if col.nullable:
            continue
        if col.default is not None or col.server_default is not None:
            continue

        t = col.type
        if isinstance(t, (Integer, BigInteger, Numeric, Float)):
            insert_data[col.name] = 0
        elif isinstance(t, string_types):
            insert_data[col.name] = ""
        elif isinstance(t, SA_Boolean):
            insert_data[col.name] = False
        elif isinstance(t, SA_DateTime):
            insert_data[col.name] = now
        elif isinstance(t, SA_Date):
            insert_data[col.name] = now.date()
        else:
            insert_data[col.name] = None

    stmt = table.insert().values(**insert_data)
    db.execute(stmt)
    return next_id


@router.post("/commit", response_model=ListingCommitResponse)
async def commit_listing_items(
    payload: ListingCommitRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> ListingCommitResponse:
    """Commit draft listing items into the inventory table.

    This endpoint is used by the LISTING UI: it accepts a batch of draft rows
    keyed by SQ catalog SKU (SqItem.sku) and creates corresponding Inventory
    rows in Supabase using the `sq_items` (SQ catalog) table.
    """
    # Normalize global default status -> InventoryStatus (also validates value)
    _ = ALLOWED_LISTING_STATUS_MAP[payload.default_status]

    # Fetch all referenced SQ catalog rows in one query using sku (logical sku_code).
    # SqItem.sku is stored as a NUMERIC column, but the API contract exposes
    # sku_code as a string. Normalise everything to a canonical string key
    # based on the integer SKU value so lookups are robust.
    normalised_codes: Dict[str, str] = {}
    for item in payload.items:
        try:
            key = str(int(item.sku_code))
        except (TypeError, ValueError):
            raise HTTPException(
                status_code=400,
                detail={"error": "invalid_sku_code", "sku_code": item.sku_code},
            )
        normalised_codes[key] = item.sku_code

    sq_rows = db.query(SqItem).filter(SqItem.sku.in_([int(k) for k in normalised_codes.keys()])).all()

    sq_by_code: Dict[str, SqItem] = {}
    for s in sq_rows:
        if s.sku is None:
            continue
        try:
            key = str(int(s.sku))
        except (TypeError, ValueError):
            continue
        sq_by_code[key] = s

    missing = [orig for key, orig in normalised_codes.items() if key not in sq_by_code]
    if missing:
        raise HTTPException(status_code=400, detail={"error": "unknown_sku_codes", "codes": missing})

    created_items: List[ListingCommitItemResponse] = []
    parts_detail_ids: List[int] = []

    try:
        # Lookup legacy StatusSKU numeric codes from tbl_parts_inventorystatus.
        # This allows us to map UI statuses (awaiting_moderation, checked)
        # onto the legacy numeric codes used by tbl_parts_inventory.
        status_id_map: Dict[str, int] = {}
        try:
            status_sql = sa_text(
                'SELECT "InventoryStatus_ID" AS id, "InventoryStatus_Name" AS name '
                'FROM "tbl_parts_inventorystatus"'
            )
            result = db.execute(status_sql)
            for row in result:
                try:
                    label_norm = str(row.name).strip().lower()
                    status_id_map[label_norm] = int(row.id)
                except Exception:
                    continue
        except Exception:
            status_id_map = {}

        # Compute starting legacy inventory ID once (MAX(ID)+1)
        legacy_table = TblPartsInventory.__table__
        try:
            max_id = db.query(func.max(legacy_table.c.ID)).scalar()
        except Exception:
            max_id = None
        next_legacy_id = int(max_id or 0) + 1

        for item in payload.items:
            key = str(int(item.sku_code))
            sq = sq_by_code[key]

            # Resolve storage: per-row overrides global
            storage_value: Optional[str] = item.storage or payload.storage
            if not storage_value:
                raise HTTPException(
                    status_code=400,
                    detail={"error": "missing_storage", "sku_code": item.sku_code},
                )

            # Resolve status
            status_key = (item.status or payload.default_status)
            status_enum = ALLOWED_LISTING_STATUS_MAP[status_key]

            # Map SQ catalog row → inventory logical fields.
            # Ensure we always have a valid inventory.sku_id by resolving or
            # creating a corresponding simplified SKU row.
            inv_title = item.title or getattr(sq, "title", None) or sq.part
            inv_price = (
                float(item.price)
                if item.price is not None
                else (float(sq.price) if sq.price is not None else None)
            )

            inv = Inventory(
                sku_id=_get_or_create_simple_sku(db, sq),
                model=sq.model,
                category=sq.category,
                condition=None,
                part_number=sq.part_number,
                title=inv_title,
                price_value=inv_price,
                price_currency=None,
                status=status_enum,
                photo_count=0,
                storage_id=storage_value,
                storage=storage_value,
                warehouse_id=item.warehouse_id,
                quantity=item.quantity,
                author=current_user.username,
            )

            db.add(inv)
            db.flush()  # assign ID

            # Create a minimal parts_detail row in Supabase to feed the listing worker.
            #
            # We avoid any new schema and populate only the fields that the
            # debug/live worker actually uses (sku, storage, price/title,
            # status_sku, and basic audit fields). Account linkage
            # (username/ebay_id) can be filled in later by dedicated tools.
            sku_str = key
            parts_status = (
                PartsDetailStatus.CHECKED.value
                if status_key == "checked"
                else PartsDetailStatus.AWAITING_MODERATION.value
            )

            pd_row = PartsDetail(
                sku=sku_str,
                override_sku=sku_str,
                storage=storage_value,
                warehouse_id=item.warehouse_id,
                status_sku=parts_status,
                status_updated_at=datetime.utcnow(),
                status_updated_by=current_user.username,
                override_title=inv_title,
                override_price=inv_price,
                listing_time_updated=datetime.utcnow(),
                record_created_by=current_user.username,
            )
            db.add(pd_row)
            db.flush()  # assign ID
            parts_detail_ids.append(pd_row.id)

            # Also mirror into legacy tbl_parts_inventory
            _insert_legacy_inventory_row(
                db=db,
                sq=sq,
                storage_value=storage_value,
                status_key=status_key,
                username=current_user.username,
                next_id=next_legacy_id,
                item_payload=item,
                status_id_map=status_id_map,
            )
            next_legacy_id += 1

            created_items.append(
                ListingCommitItemResponse(
                    inventory_id=inv.id,
                    sku_code=str(int(sq.sku)) if sq.sku is not None else "",
                    storage=inv.storage,
                    status=inv.status.value if inv.status else "",
                )
            )

        db.commit()
    except HTTPException:
        # Re-raise user errors without wrapping
        db.rollback()
        raise
    except SQLAlchemyError as e:
        db.rollback()
        logger.error("listing.commit failed user=%s error=%s", current_user.id, str(e))
        raise HTTPException(status_code=400, detail={"error": "commit_failed", "message": str(e)})

    return ListingCommitResponse(
        created_count=len(created_items),
        items=created_items,
        parts_detail_ids=parts_detail_ids,
    )





// FILE: frontend/src/pages/ListingPage.tsx
import { useMemo, useState } from 'react';
import FixedHeader from '@/components/FixedHeader';
import { DataGridPage } from '@/components/DataGridPage';
import api from '@/lib/apiClient';
import { useToast } from '@/hooks/use-toast';
import { WorkerDebugTerminalModal } from '@/components/WorkerDebugTerminalModal';
import { useEbayListingDebug } from '@/hooks/useEbayListingDebug';

type DraftListingStatus = 'awaiting_moderation' | 'checked';

interface DraftListingItem {
  tempId: string;
  skuId: number;
  skuCode: string;
  model?: string | null;
  category?: string | null;
  price: number;
  quantity: number;
  condition?: string | null;
  title?: string | null;
  storage: string;
  status: DraftListingStatus;
  warehouseId?: number | null;
}

function uuid(): string {
  return Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2);
}

export default function ListingPage() {
  const { toast } = useToast();

  const [draftItems, setDraftItems] = useState<DraftListingItem[]>([]);
  const [selectedDraftIds, setSelectedDraftIds] = useState<Set<string>>(new Set());
  const [globalStorage, setGlobalStorage] = useState('');
  const [globalStatus, setGlobalStatus] = useState<DraftListingStatus>('awaiting_moderation');
  const [isCommitting, setIsCommitting] = useState(false);

  // Debug listing worker (parts_detail) – dev only
  const [debugIds, setDebugIds] = useState('');
  const [debugMaxItems, setDebugMaxItems] = useState<number | ''>(50);

  const {
    isDebugEnabled,
    runDebugForIds,
    runDebugForAutoCandidates,
    trace: debugTrace,
    open: debugOpen,
    setOpen: setDebugOpen,
    loading: debugLoading,
    error: debugError,
  } = useEbayListingDebug();

  const selectedDraftItems = useMemo(
    () => draftItems.filter((i) => selectedDraftIds.has(i.tempId)),
    [draftItems, selectedDraftIds],
  );

  const handleAddSkuToDraft = (row: Record<string, any>) => {
    if (!row || typeof row.id !== 'number') return;

    const skuId = row.id as number;
    const rawSku = row.sku_code ?? row.skuCode ?? '';
    const skuCode = rawSku !== null && rawSku !== undefined ? String(rawSku) : '';
    const model = (row.model || null) as string | null;
    const category = (row.category || null) as string | null;
    const price = typeof row.price === 'number' ? row.price : Number(row.price || 0) || 0;
    // The SKU grid exposes condition as either `condition_description` (human label)
    // or `condition_id`. Prefer the label if present.
    const condition = (row.condition_description || row.condition || null) as string | null;
    const title = (row.title || null) as string | null;

    // Duplicate strategy: if SKU already exists in draft, increment quantity.
    setDraftItems((prev) => {
      const existing = prev.find((i) => i.skuId === skuId);
      if (existing) {
        return prev.map((i) =>
          i.skuId === skuId ? { ...i, quantity: i.quantity + 1 } : i,
        );
      }
      return [
        ...prev,
        {
          tempId: uuid(),
          skuId,
          skuCode,
          model,
          category,
          price,
          quantity: 1,
          condition,
          title,
          storage: '',
          status: 'awaiting_moderation',
          warehouseId: undefined,
        },
      ];
    });
  };

  const applyGlobalToSelected = () => {
    if (selectedDraftIds.size === 0) {
      toast({ title: 'No rows selected', description: 'Select rows in the bottom grid first.' });
      return;
    }

    setDraftItems((prev) =>
      prev.map((item) => {
        if (!selectedDraftIds.has(item.tempId)) return item;
        return {
          ...item,
          storage: globalStorage || item.storage,
          status: globalStatus,
        };
      }),
    );
  };

  const removeSelected = () => {
    if (selectedDraftIds.size === 0) return;
    setDraftItems((prev) => prev.filter((i) => !selectedDraftIds.has(i.tempId)));
    setSelectedDraftIds(new Set());
  };

  const clearAll = () => {
    setDraftItems([]);
    setSelectedDraftIds(new Set());
  };

  const toggleDraftSelection = (tempId: string) => {
    setSelectedDraftIds((prev) => {
      const next = new Set(prev);
      if (next.has(tempId)) next.delete(tempId);
      else next.add(tempId);
      return next;
    });
  };

  const toggleSelectAllDraft = () => {
    if (selectedDraftIds.size === draftItems.length) {
      setSelectedDraftIds(new Set());
    } else {
      setSelectedDraftIds(new Set(draftItems.map((i) => i.tempId)));
    }
  };

  const handleCommitSelected = async () => {
    if (selectedDraftItems.length === 0) {
      toast({
        title: 'Nothing to commit',
        description: 'Select rows in the draft grid first.',
      });
      return;
    }

    const invalid = selectedDraftItems.filter((i) => !i.storage.trim());
    if (invalid.length > 0) {
      toast({
        title: 'Storage required',
        description: 'All selected rows must have Storage set before commit.',
        variant: 'destructive',
      });
      return;
    }

    const payload = {
      model_id: null,
      storage: globalStorage || undefined,
      default_status: globalStatus,
      items: selectedDraftItems.map((item) => ({
        sku_code: item.skuCode,
        price: item.price,
        quantity: item.quantity,
        condition: item.condition,
        title: item.title,
        storage: item.storage,
        status: item.status,
        warehouse_id: item.warehouseId ?? undefined,
      })),
    };

    try {
      setIsCommitting(true);
      const resp = await api.post('/api/listing/commit', payload);
      const createdCount = resp.data?.created_count ?? 0;
      toast({
        title: 'Listing committed',
        description: `${createdCount} items committed to inventory`,
      });

      const committedSkuCodes = new Set(resp.data?.items?.map((i: any) => i.sku_code) ?? []);
      setDraftItems((prev) => prev.filter((i) => !committedSkuCodes.has(i.skuCode)));
      setSelectedDraftIds(new Set());

      // When debug mode is enabled, immediately run the listing worker for the
      // freshly created parts_detail rows so we can see the full trace.
      const pdIds: number[] = resp.data?.parts_detail_ids ?? [];
      if (isDebugEnabled && Array.isArray(pdIds) && pdIds.length > 0) {
        try {
          await runDebugForIds(pdIds, {
            dryRun: false,
            maxItems: pdIds.length || 50,
          });
        } catch {
          // Errors are surfaced inside the debug hook (toast + error state).
        }
      }
    } catch (e: any) {
      const detail = e?.response?.data?.detail ?? e?.message ?? 'Commit failed';
      toast({
        title: 'Commit failed',
        description: String(detail),
        variant: 'destructive',
      });
    } finally {
      setIsCommitting(false);
    }
  };

  const handleRunDebugWorker = async () => {
    if (!isDebugEnabled) return;
    const raw = debugIds.trim();
    if (!raw) {
      toast({
        title: 'No IDs provided',
        description: 'Enter parts_detail IDs (comma separated).',
        variant: 'destructive',
      });
      return;
    }

    const ids = Array.from(
      new Set(
        raw
          .split(/[\s,]+/)
          .map((s) => s.trim())
          .filter(Boolean)
          .map((s) => Number(s))
          .filter((n) => Number.isFinite(n) && n > 0),
      ),
    );

    if (!ids.length) {
      toast({
        title: 'Invalid IDs',
        description: 'Could not parse any numeric IDs from input.',
        variant: 'destructive',
      });
      return;
    }

    try {
      await runDebugForIds(ids, { dryRun: false, maxItems: 50 });
    } catch {
      // Errors are already surfaced via the debug hook (toast + error state).
    }
  };

  const handleRunBulkAuto = async () => {
    if (!isDebugEnabled) return;
    const max = typeof debugMaxItems === 'number' && debugMaxItems > 0 ? debugMaxItems : 50;
    try {
      await runDebugForAutoCandidates({ dryRun: false, maxItems: max });
    } catch {
      // Errors are already surfaced via the debug hook (toast + error state).
    }
  };

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      <FixedHeader />
      <div className="pt-16 flex-1 px-4 py-4 overflow-hidden flex flex-col gap-4">
        <h1 className="text-2xl font-bold mb-2">Listing (SKU → Inventory)</h1>

        {/* Top section: SKU catalog grid */}
        <div className="flex-[2] min-h-0 border rounded-lg bg-white flex flex-col">
          <div className="flex items-center justify-between px-3 py-2 border-b bg-gray-50 text-xs">
            <div className="font-semibold">SKU catalog</div>
            <div className="flex items-center gap-2">
              <span className="text-gray-500">Select SKUs and click Add to listing</span>
            </div>
          </div>
          <div className="flex-1 min-h-0">
            <DataGridPage
              gridKey="sku_catalog"
              title="SKU catalog"
              onRowClick={handleAddSkuToDraft}
            />
          </div>
        </div>

        {/* Bottom section: Draft listing grid */}
        <div className="flex-[1] min-h-[220px] border rounded-lg bg-white flex flex-col">
          <div className="flex items-center justify-between px-3 py-2 border-b bg-gray-50 text-xs gap-4">
            <div className="font-semibold">Draft listing (per physical computer)</div>
            <div className="flex items-center gap-2 flex-wrap">
              <input
                className="border rounded px-2 py-1 text-xs w-32"
                placeholder="Storage (e.g. B16:1)"
                value={globalStorage}
                onChange={(e) => setGlobalStorage(e.target.value)}
              />
              <select
                className="border rounded px-2 py-1 text-xs"
                value={globalStatus}
                onChange={(e) => setGlobalStatus(e.target.value as DraftListingStatus)}
              >
                <option value="awaiting_moderation">Awaiting moderation</option>
                <option value="checked">Checked</option>
              </select>
              <button
                className="px-2 py-1 text-xs border rounded bg-gray-100 hover:bg-gray-200"
                onClick={applyGlobalToSelected}
              >
                Apply to selected
              </button>
              <button
                className="px-2 py-1 text-xs border rounded bg-white hover:bg-gray-100"
                onClick={removeSelected}
              >
                Remove selected
              </button>
              <button
                className="px-2 py-1 text-xs border rounded bg-white hover:bg-gray-100"
                onClick={clearAll}
              >
                Clear all
              </button>
              <button
                className="ml-2 px-3 py-1 text-xs rounded bg-green-600 text-white hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed"
                onClick={handleCommitSelected}
                disabled={isCommitting || selectedDraftItems.length === 0}
              >
                {isCommitting ? 'Committing…' : 'Commit selected'}
              </button>
            </div>
          </div>

          <div className="flex-1 min-h-0 overflow-auto">
            <table className="min-w-full text-[11px] border-collapse">
              <thead className="bg-gray-100">
                <tr>
                  <th className="ui-table-header px-2 py-1 border-b border-r w-6">
                    <input
                      type="checkbox"
                      className="h-3 w-3"
                      checked={draftItems.length > 0 && selectedDraftIds.size === draftItems.length}
                      onChange={toggleSelectAllDraft}
                    />
                  </th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">#</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">SKU</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">Model</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">Category</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r text-right">Price</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r text-center">Qty</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">Condition</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">Storage</th>
                  <th className="ui-table-header px-2 py-1 border-b border-r">Status</th>
                  <th className="ui-table-header px-2 py-1 border-b">Title</th>
                </tr>
              </thead>
              <tbody>
                {draftItems.length === 0 ? (
                  <tr>
                    <td colSpan={11} className="px-3 py-4 text-center text-gray-500 text-xs">
                      No draft items. Select SKUs in the top grid and click "Add to listing".
                    </td>
                  </tr>
                ) : (
                  draftItems.map((item, idx) => (
                    <tr
                      key={item.tempId}
                      className={`border-t ${idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'} hover:bg-blue-50`}
                    >
                      <td className="ui-table-cell px-2 py-1 border-r text-center">
                        <input
                          type="checkbox"
                          className="h-3 w-3"
                          checked={selectedDraftIds.has(item.tempId)}
                          onChange={() => toggleDraftSelection(item.tempId)}
                        />
                      </td>
                      <td className="ui-table-cell px-2 py-1 border-r text-right text-gray-500">{idx + 1}</td>
                      <td className="ui-table-cell px-2 py-1 border-r font-mono">{item.skuCode}</td>
                      <td className="ui-table-cell px-2 py-1 border-r truncate max-w-xs">
                        {item.model || '-'}
                      </td>
                      <td className="ui-table-cell px-2 py-1 border-r">{item.category || '-'}</td>
                      <td className="ui-table-cell px-2 py-1 border-r text-right">
                        {item.price ? item.price.toFixed(2) : '-'}
                      </td>
                      <td className="ui-table-cell px-2 py-1 border-r text-center">{item.quantity}</td>
                      <td className="ui-table-cell px-2 py-1 border-r">{item.condition || '-'}</td>
                      <td className="ui-table-cell px-2 py-1 border-r font-mono">
                        <input
                          className="border rounded px-1 py-0.5 text-[11px] w-20"
                          value={item.storage}
                          onChange={(e) =>
                            setDraftItems((prev) =>
                              prev.map((p) =>
                                p.tempId === item.tempId ? { ...p, storage: e.target.value } : p,
                              ),
                            )
                          }
                        />
                      </td>
                      <td className="ui-table-cell px-2 py-1 border-r">
                        {item.status === 'awaiting_moderation' ? 'Awaiting moderation' : 'Checked'}
                      </td>
                      <td className="ui-table-cell px-2 py-1 truncate max-w-md">{item.title || '-'}</td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>
        </div>

        {isDebugEnabled && (
          <div className="mt-4 border rounded-lg bg-white p-3 text-xs font-mono text-gray-700">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold text-gray-800">eBay Listing Worker Debug (parts_detail)</div>
              {debugLoading && <span className="text-blue-600">Running…</span>}
            </div>
            <div className="flex flex-wrap items-center gap-2 mb-2">
              <input
                className="border rounded px-2 py-1 text-xs min-w-[260px]"
                placeholder="parts_detail IDs (e.g. 101, 102, 103)"
                value={debugIds}
                onChange={(e) => setDebugIds(e.target.value)}
              />
              <button
                className="px-3 py-1 text-xs rounded bg-black text-white hover:bg-gray-800 disabled:bg-gray-300 disabled:cursor-not-allowed"
                onClick={handleRunDebugWorker}
                disabled={debugLoading}
              >
                Run listing worker (debug)
              </button>
              <input
                type="number"
                min={1}
                max={200}
                className="border rounded px-2 py-1 text-xs w-24"
                placeholder="max items"
                value={debugMaxItems === '' ? '' : debugMaxItems}
                onChange={(e) => {
                  const v = e.target.value;
                  setDebugMaxItems(v === '' ? '' : Number(v));
                }}
              />
              <button
                className="px-3 py-1 text-xs rounded bg-blue-700 text-white hover:bg-blue-800 disabled:bg-gray-300 disabled:cursor-not-allowed"
                onClick={handleRunBulkAuto}
                disabled={debugLoading}
              >
                Run worker for Checked (bulk)
              </button>
            </div>
            <p className="text-[11px] text-gray-500 mb-1">
              Bulk mode calls POST /api/debug/ebay/list-once without explicit ids; the backend auto-selects
              up to <span className="font-semibold">max_items</span> parts_detail rows with
              <code className="mx-1">status_sku = Checked</code>, <code className="mx-1">item_id IS NULL</code>, and no
              freeze/cancel flags, grouped by account and published in batches.
            </p>
            {debugError && <div className="text-red-600 text-[11px]">Error: {debugError}</div>}
          </div>
        )}
      </div>

      {isDebugEnabled && (
        <WorkerDebugTerminalModal
          isOpen={debugOpen}
          onClose={() => setDebugOpen(false)}
          trace={debugTrace}
        />
      )}
    </div>
  );
}




